<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Umbrella Shade Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/suncalc/1.8.0/suncalc.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/dayjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/utc.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/timezone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        html, body {
            overscroll-behavior: none; /* Disables pull-to-refresh */
        }
        /* Lock scrolling on mobile/tablet */
        @media (max-width: 1023px) {
            html, body {
                overflow: hidden;
            }
        }
        body {
            font-family: 'Inter', sans-serif;
        }
        .loader {
            border: 0.5vmin solid #4a5568; /* gray-700 */
            border-top: 0.5vmin solid #4299e1; /* blue-400 */
            border-radius: 50%;
            width: 5vmin;
            height: 5vmin;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        input:disabled {
            background-color: #2d3748; /* gray-800 */
            cursor: not-allowed;
        }
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type=number] {
            -moz-appearance: textfield;
        }
        .unit-toggle {
            background-color: transparent;
            transition: background-color 0.2s;
        }
        .active-unit {
            background-color: #3b82f6; /* blue-500 */
            color: white;
        }
        input[type="time"]::-webkit-calendar-picker-indicator,
        input[type="date"]::-webkit-calendar-picker-indicator {
            display: none;
        }
        #shadow-ellipse {
            cursor: grab;
        }
        #shadow-ellipse:active {
            cursor: grabbing;
        }
    </style>
</head>
<body class="bg-black text-gray-300 flex items-center justify-center min-h-screen p-2">
    <div class="w-full max-w-md mx-auto space-y-2">
        <div class="text-center">
            <h1 class="font-bold text-blue-400" style="font-size: 6vmin;">Shade Finder</h1>
            <p class="text-gray-400" style="font-size: 2.25vmin;">Plan your perfect spot in the shade.</p>
        </div>

        <div id="map-container" class="relative w-full aspect-square rounded-lg overflow-hidden border-2 border-gray-700">
              <svg id="sky" viewBox="0 0 200 200" class="absolute inset-0 w-full h-full">
                          <defs>
                              <filter id="text-shadow" x="-20%" y="-20%" width="140%" height="140%">
                                  <feGaussianBlur in="SourceAlpha" stdDeviation="0.5"/>
                                  <feOffset dx="0.5" dy="0.5" result="offsetblur"/>
                                  <feFlood flood-color="black" flood-opacity="0.7"/>
                                  <feComposite in2="offsetblur" operator="in"/>
                                  <feMerge>
                                      <feMergeNode/>
                                      <feMergeNode in="SourceGraphic"/>
                                  </feMerge>
                              </filter>
                          </defs>
                          <g id="grid-overlay"></g>
                          <text x="96" y="15" fill="currentColor" class="opacity-75 font-semibold" style="font-size: 2vmin;" filter="url(#text-shadow)">N</text>
                          <text x="96" y="190" fill="currentColor" class="opacity-75 font-semibold" style="font-size: 2vmin;" filter="url(#text-shadow)">S</text>
                          <text x="10" y="104" fill="currentColor" class="opacity-75 font-semibold" style="font-size: 2vmin;" filter="url(#text-shadow)">W</text>
                          <text x="182" y="104" fill="currentColor" class="opacity-75 font-semibold" style="font-size: 2vmin;" filter="url(#text-shadow)">E</text>
                          <line x1="100" y1="18" x2="100" y2="25" stroke="currentColor" stroke-width="0.5" class="opacity-50"/>
                          <line x1="100" y1="182" x2="100" y2="175" stroke="currentColor" stroke-width="0.5" class="opacity-50"/>
                          <line x1="18" y1="100" x2="25" y2="100" stroke="currentColor" stroke-width="0.5" class="opacity-50"/>
                          <line x1="182" y1="100" x2="175" y2="100" stroke="currentColor" stroke-width="0.5" class="opacity-50"/>
                          
                          <g id="info-text-group" text-anchor="middle" fill="currentColor" class="font-semibold" style="font-size: 1.5vmin;">
                                <text id="shade-dims-text" x="100" y="25"></text>
                                <text id="center-pos-text" x="100" y="33"></text>
                          </g>
                          
                          <circle id="sun-indicator" r="5" fill="#FBBF24" fill-opacity="0.9" stroke="#F59E0B" stroke-width="0.5" />
                          <path id="shadow-path" fill="#3b82f6" fill-opacity="0.4" />
                          <g id="hourly-dots-group"></g>
                          
                          <ellipse id="shadow-ellipse" cx="100" cy="100" rx="20" ry="20" fill="#3b82f6" fill-opacity="0.5" stroke="#3b82f6" stroke-width="1"/>
                          <circle id="umbrella" cx="100" cy="100" r="20" fill="rgb(156 163 175 / 0.5)" stroke="rgb(107 114 128)" stroke-width="1.5"/>
              </svg>
            <div id="night-message" class="absolute inset-0 bg-black/50 flex items-center justify-center text-white font-semibold hidden" style="font-size: 4vmin;">
                <p>It's Nighttime!</p>
            </div>
                  <div id="loader" class="absolute inset-0 bg-gray-800/70 flex items-center justify-center">
                          <div class="loader"></div>
            </div>

            <div class="absolute bottom-2 left-2 grid grid-cols-[auto_1fr] gap-x-1 gap-y-1 items-center">
                <button id="getLocationBtn" title="Get Current Location" class="p-1 rounded-md bg-gray-900/70 backdrop-blur-sm hover:bg-gray-700">
                    <svg class="w-4 h-4 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                </button>
                <input type="number" id="lat" step="0.0001" class="bg-gray-900/70 backdrop-blur-sm rounded-md p-0.5 border-gray-600 w-full text-left" style="font-size: 1.5vmin;" placeholder="Latitude">
                
                <div class="w-4 h-4"></div> <input type="number" id="lon" step="0.0001" class="bg-gray-900/70 backdrop-blur-sm rounded-md p-0.5 border-gray-600 w-full text-left" style="font-size: 1.5vmin;" placeholder="Longitude">
            </div>

            <div class="absolute bottom-2 right-2 grid grid-cols-[auto_1fr] gap-x-1 gap-y-1 items-center">
                      <button id="date-reset-btn" title="Set to today" class="p-1 rounded-md bg-gray-900/70 backdrop-blur-sm hover:bg-gray-700">
                              <svg class="w-4 h-4 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                      </button>
                <input type="date" id="date" class="bg-gray-900/70 backdrop-blur-sm rounded-md p-0.5 border-gray-600 w-full" style="font-size: 1.5vmin;">

                      <button id="time-reset-btn" title="Set to current time" class="p-1 rounded-md bg-gray-900/70 backdrop-blur-sm hover:bg-gray-700">
                              <svg class="w-4 h-4 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                      </button>
                <input type="text" id="time-input-box" class="bg-gray-900/70 backdrop-blur-sm rounded-md px-1 py-0.5 border-gray-600 w-full" style="font-size: 1.5vmin;" pattern="([01]?[0-9]|2[0-3]):[0-5][0-9]" placeholder="HH:mm">
                
                      <button id="timezone-reset-btn" title="Auto-detect time zone" class="p-1 rounded-md bg-gray-900/70 backdrop-blur-sm hover:bg-gray-700">
                              <svg class="w-4 h-4 text-gray-300 transform rotate-90" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3.51 9h16.98M3.51 15h16.98M12 3a9 9 0 015.657 15.343"></path>
                              </svg>
                      </button>
                      <div class="w-full">
                              <select id="timezone-picker" class="bg-gray-900/70 backdrop-blur-sm rounded-md p-0.5 border-gray-600 w-auto" style="font-size: 1.5vmin;"></select>
                      </div>
            </div>
        </div>

        <div class="flex justify-center items-center flex-wrap gap-x-4 gap-y-1 text-gray-400 pt-1" style="font-size: 2.25vmin;">
            <div class="flex items-center space-x-1.5">
                <span class="w-3 h-3 rounded-full bg-gray-400/50 border border-gray-500"></span>
                <span>Umbrella</span>
            </div>
            <div class="flex items-center space-x-1.5">
                <span class="w-3 h-3 rounded-full bg-blue-500/50 border border-blue-600"></span>
                <span>Shade</span>
            </div>
             <div class="flex items-center space-x-1.5">
                <span class="w-3 h-3 rounded-full bg-blue-500/40"></span>
                <span>Day's Path</span>
            </div>
             <div class="flex items-center space-x-1.5">
                <svg width="12" height="12" viewBox="0 0 12 12" class="opacity-100"><path d="M0 6 L12 6 M6 0 L6 12" stroke="currentColor" stroke-width="0.5"></path></svg>
                <span id="grid-legend-text">2ft Grid</span>
            </div>
        </div>
        
        <div class="space-y-2 pt-1">
            <div class="flex justify-center items-center pb-2">
                <div class="flex items-center border border-gray-600 rounded-md overflow-hidden" style="font-size: 2.25vmin;">
                    <button id="unit-imperial" class="px-4 py-1 unit-toggle active-unit">Imperial</button>
                    <button id="unit-metric" class="px-4 py-1 unit-toggle">Metric</button>
                </div>
            </div>
            <div class="grid grid-cols-2 gap-2">
                <div>
                    <div class="flex justify-between items-center">
                        <label for="height" id="height-label" class="font-medium text-gray-300" style="font-size: 1.75vmin;">Height to Edge of Umbrella (ft)</label>
                    </div>
                    <input id="height" type="number" value="5.5" step="0.1" class="w-full mt-1 p-1 rounded-md border bg-gray-700 border-gray-600" style="font-size: 2.25vmin;">
                </div>
                <div>
                    <div class="flex justify-between items-center">
                        <label for="diameter" id="diameter-label" class="font-medium text-gray-300" style="font-size: 1.75vmin;">Umbrella Diameter (ft)</label>
                   </div>
                   <input id="diameter" type="number" value="5" step="0.1" class="w-full mt-1 p-1 rounded-md border bg-gray-700 border-gray-600" style="font-size: 2.25vmin;">
                </div>
            </div>
        </div>
         <p id="error-message" class="text-red-500 hidden text-center pt-1" style="font-size: 2vmin;"></p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            dayjs.extend(window.dayjs_plugin_utc);
            dayjs.extend(window.dayjs_plugin_timezone);

            const heightInput = document.getElementById('height');
            const diameterInput = document.getElementById('diameter');
            const timeInputBox = document.getElementById('time-input-box');
            const dateInput = document.getElementById('date');
            
            const svg = document.getElementById('sky');
            const umbrellaSVG = document.getElementById('umbrella');
            const shadowEllipseSVG = document.getElementById('shadow-ellipse');
            const shadowPath = document.getElementById('shadow-path');
            const hourlyDotsGroup = document.getElementById('hourly-dots-group');
            const nightMessage = document.getElementById('night-message');
            const gridOverlay = document.getElementById('grid-overlay');
            
            const latInput = document.getElementById('lat');
            const lonInput = document.getElementById('lon');
            const getLocationBtn = document.getElementById('getLocationBtn');

            const loader = document.getElementById('loader');
            const errorMessage = document.getElementById('error-message');
            
            const centerPosText = document.getElementById('center-pos-text');
            const shadeDimsText = document.getElementById('shade-dims-text');

            const heightLabel = document.getElementById('height-label');
            const diameterLabel = document.getElementById('diameter-label');
            
            const dateResetBtn = document.getElementById('date-reset-btn');
            const timeResetBtn = document.getElementById('time-reset-btn');
            const timezonePicker = document.getElementById('timezone-picker');
            const timezoneResetBtn = document.getElementById('timezone-reset-btn');
            
            const unitImperialBtn = document.getElementById('unit-imperial');
            const unitMetricBtn = document.getElementById('unit-metric');
            const gridLegendText = document.getElementById('grid-legend-text');

            const VIEWBOX_SIZE = 200;
            const FEET_TO_METERS = 0.3048;
            const METERS_TO_FEET = 3.28084;
            const MIN_ALTITUDE_RAD = 0.0872665; // 5 degrees in radians

            let isDragging = false;
            let dailySunPath = [];
            let lastMapLat = null, lastMapLon = null;
            let currentUnitSystem = 'imperial';
            
            function getCombinedDate() {
                const dateStr = dateInput.value;
                const timeStr = timeInputBox.value;
                if (!dateStr || !timeStr) return new Date();

                const isoStr = `${dateStr}T${timeStr}`;
                const selectedTimezone = timezonePicker.value;

                return dayjs.tz(isoStr, selectedTimezone).toDate();
            }

            function setUnitSystem(system) {
                if (system === currentUnitSystem) return; 

                const heightVal = parseFloat(heightInput.value);
                const diameterVal = parseFloat(diameterInput.value);

                if (system === 'metric') {
                    unitMetricBtn.classList.add('active-unit');
                    unitImperialBtn.classList.remove('active-unit');
                    if (!isNaN(heightVal)) heightInput.value = (heightVal * FEET_TO_METERS).toFixed(2);
                    if (!isNaN(diameterVal)) diameterInput.value = (diameterVal * FEET_TO_METERS).toFixed(2);
                    heightLabel.textContent = 'Height to Edge of Umbrella (m)';
                    diameterLabel.textContent = 'Umbrella Diameter (m)';
                    gridLegendText.textContent = '0.6m Grid';
                } else { // imperial
                    unitImperialBtn.classList.add('active-unit');
                    unitMetricBtn.classList.remove('active-unit');
                    if (!isNaN(heightVal)) heightInput.value = (heightVal * METERS_TO_FEET).toFixed(1);
                    if (!isNaN(diameterVal)) diameterInput.value = (diameterVal * METERS_TO_FEET).toFixed(1);
                    heightLabel.textContent = 'Height to Edge of Umbrella (ft)';
                    diameterLabel.textContent = 'Umbrella Diameter (ft)';
                    gridLegendText.textContent = '2ft Grid';
                }
                currentUnitSystem = system;
                calculateAndDraw();
            }
            
            function populateTimezonePicker() {
                const selectedDate = dateInput.value ? new Date(dateInput.value + 'T12:00:00Z') : new Date();
                const allTimezones = Intl.supportedValuesOf('timeZone');
                const currentSelectedTz = timezonePicker.value;
                timezonePicker.innerHTML = '';

                const tzMap = new Map();

                allTimezones.forEach(tz => {
                    try {
                        const formatter = new Intl.DateTimeFormat('en-US', {
                            timeZone: tz,
                            timeZoneName: 'short'
                        });
                        const parts = formatter.formatToParts(selectedDate);
                        const tzNamePart = parts.find(part => part.type === 'timeZoneName');

                        if (tzNamePart) {
                            tzMap.set(tz, `${tz.split('/').pop().replace(/_/g, ' ')} (${tzNamePart.value})`);
                        }
                    } catch (e) { /* Ignore invalid timezones */ }
                });
                
                const sortedTzs = [...tzMap.entries()].sort((a, b) => a[1].localeCompare(b[1]));

                sortedTzs.forEach(([value, text]) => {
                    const option = document.createElement('option');
                    option.value = value;
                    option.textContent = text;
                    timezonePicker.appendChild(option);
                });
                
                try {
                    timezonePicker.value = currentSelectedTz || dayjs.tz.guess();
                } catch (e) {
                    if(timezonePicker.options.length > 0) {
                         timezonePicker.selectedIndex = 0;
                       }
                }
            }
            
            function updateMapBackground(lat, lon, scale) {
                const mapContainer = document.getElementById('map-container');
                
                const viewboxWidthInFeet = VIEWBOX_SIZE / scale;
                const feetPerDegree = 364000; // Approx feet per degree latitude

                const cosLat = Math.max(0.01, Math.cos(lat * Math.PI / 180)); // Clamp to avoid blowups near poles
                const deltaLon = (viewboxWidthInFeet / (feetPerDegree * cosLat)) / 2;

                const deltaLat = (viewboxWidthInFeet / feetPerDegree) / 2;
                
                const paddingFactor = 1.1; 
                const minLon = lon - (deltaLon * paddingFactor);
                const minLat = lat - (deltaLat * paddingFactor);
                const maxLon = lon + (deltaLon * paddingFactor);
                const maxLat = lat + (deltaLat * paddingFactor);

                const bbox = `${minLon},${minLat},${maxLon},${maxLat}`;
                const mapUrl = `https://render.openstreetmap.org/cgi-bin/export?bbox=${bbox}&scale=10000&format=png`;

                mapContainer.style.backgroundImage = `url('${mapUrl}')`;
                mapContainer.style.backgroundSize = 'cover';
                mapContainer.style.backgroundPosition = 'center';
            }

            function calculateAndDraw() {
                errorMessage.classList.add('hidden');
                
                const heightVal = parseFloat(heightInput.value);
                const diameterVal = parseFloat(diameterInput.value);
                const userLat = parseFloat(latInput.value);
                const userLon = parseFloat(lonInput.value);
                
                if (isNaN(heightVal) || isNaN(diameterVal) || isNaN(userLat) || isNaN(userLon)) {
                    errorMessage.textContent = 'Please enter valid numbers for dimensions and location.';
                    errorMessage.classList.remove('hidden');
                    return;
                }
                
                const heightInFeet = currentUnitSystem === 'imperial' ? heightVal : heightVal * METERS_TO_FEET;
                const diameterInFeet = currentUnitSystem === 'imperial' ? diameterVal : diameterVal * METERS_TO_FEET;
                
                const sunTimesForScale = SunCalc.getTimes(getCombinedDate(), userLat, userLon);
                let minAltitudeForScale = MIN_ALTITUDE_RAD; 

                if (sunTimesForScale.sunrise instanceof Date && !isNaN(sunTimesForScale.sunrise)) {
                    const sunrisePlusOneMinute = new Date(sunTimesForScale.sunrise.getTime() + 60000);
                    const sunrisePos = SunCalc.getPosition(sunrisePlusOneMinute, userLat, userLon);
                    
                    if (sunrisePos.altitude > 0) {
                        minAltitudeForScale = sunrisePos.altitude;
                    }
                }

                const safeAltitude = Math.max(minAltitudeForScale, MIN_ALTITUDE_RAD);
                const maxShadowOffset = heightInFeet / Math.tan(safeAltitude);

                const maxElongatedRadius = (diameterInFeet / 2) / Math.sin(minAltitudeForScale);
                const maxExtent = maxShadowOffset + maxElongatedRadius;

                const maxDim = maxExtent * 0.6655; // Zoomed out 10% more
                const scale = VIEWBOX_SIZE / (maxDim * 1.1);
                
                if (userLat !== lastMapLat || userLon !== lastMapLon) {
                    updateMapBackground(userLat, userLon, scale);
                    lastMapLat = userLat;
                    lastMapLon = userLon;
                }

                const radiusScaled = (diameterInFeet / 2) * scale;
                umbrellaSVG.setAttribute('r', radiusScaled);

                gridOverlay.innerHTML = '';
                const gridSpacingFeet = 2;
                const gridSpacingSVG = gridSpacingFeet * scale;
                for (let x = 100; x < VIEWBOX_SIZE; x += gridSpacingSVG) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x); line.setAttribute('y1', 0); line.setAttribute('x2', x); line.setAttribute('y2', VIEWBOX_SIZE);
                    line.setAttribute('stroke', 'white'); line.setAttribute('stroke-width', '0.25'); line.setAttribute('class', 'opacity-30');
                    gridOverlay.appendChild(line);
                }
                 for (let x = 100 - gridSpacingSVG; x > 0; x -= gridSpacingSVG) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x); line.setAttribute('y1', 0); line.setAttribute('x2', x); line.setAttribute('y2', VIEWBOX_SIZE);
                    line.setAttribute('stroke', 'white'); line.setAttribute('stroke-width', '0.25'); line.setAttribute('class', 'opacity-30');
                    gridOverlay.appendChild(line);
                }
                 for (let y = 100; y < VIEWBOX_SIZE; y += gridSpacingSVG) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', 0); line.setAttribute('y1', y); line.setAttribute('x2', VIEWBOX_SIZE); line.setAttribute('y2', y);
                    line.setAttribute('stroke', 'white'); line.setAttribute('stroke-width', '0.25'); line.setAttribute('class', 'opacity-30');
                    gridOverlay.appendChild(line);
                }
                 for (let y = 100 - gridSpacingSVG; y > 0; y -= gridSpacingSVG) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', 0); line.setAttribute('y1', y); line.setAttribute('x2', VIEWBOX_SIZE); line.setAttribute('y2', y);
                    line.setAttribute('stroke', 'white'); line.setAttribute('stroke-width', '0.25'); line.setAttribute('class', 'opacity-30');
                    gridOverlay.appendChild(line);
                }
                
                const now = getCombinedDate();
                let sunPosition = SunCalc.getPosition(now, userLat, userLon);
                if (sunPosition.altitude > (Math.PI / 2) - 0.01) { 
                    const pastPos = SunCalc.getPosition(new Date(now.getTime() - 60000), userLat, userLon);
                    sunPosition.azimuth = pastPos.azimuth;
                }
                const sunTimes = SunCalc.getTimes(now, userLat, userLon);
                
                const sunIndicator = document.getElementById('sun-indicator');

                hourlyDotsGroup.innerHTML = ''; 
                if (sunTimes.sunrise instanceof Date && !isNaN(sunTimes.sunrise)) {
                    let hourMarker = new Date(sunTimes.sunrise);
                    if (hourMarker.getMinutes() !== 0 || hourMarker.getSeconds() !== 0 || hourMarker.getMilliseconds() !== 0) {
                        hourMarker.setHours(hourMarker.getHours() + 1);
                        hourMarker.setMinutes(0, 0, 0);
                    }
                    while (hourMarker < sunTimes.sunset) {
                        let pos = SunCalc.getPosition(hourMarker, userLat, userLon);
                        if (pos.altitude > (Math.PI / 2) - 0.01) {
                            const pastPos = SunCalc.getPosition(new Date(hourMarker.getTime() - 60000), userLat, userLon);
                            pos.azimuth = pastPos.azimuth;
                        }

                        if (pos.altitude > 0) {
                            const offset = (heightInFeet / Math.tan(pos.altitude)) * scale;
                            const shadowX = 100 + offset * Math.sin(pos.azimuth);
                            const shadowY = 100 - offset * Math.cos(pos.azimuth);

                            const hourText = String(hourMarker.getHours()).padStart(2, '0');
                            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            text.setAttribute('x', shadowX.toFixed(2));
                            text.setAttribute('y', shadowY.toFixed(2));
                            text.setAttribute('fill', 'white');
                            text.setAttribute('fill-opacity', '0.7');
                            text.setAttribute('font-size', '4');
                            text.setAttribute('text-anchor', 'middle');
                            text.setAttribute('dominant-baseline', 'middle');
                            text.textContent = hourText;
                            hourlyDotsGroup.appendChild(text);
                        }
                        hourMarker.setHours(hourMarker.getHours() + 1);
                    }
                }
                
                const shadowSteps = [];
                dailySunPath = []; 
                const stepMinutes = 1;
                
                if (sunTimes.sunrise instanceof Date && !isNaN(sunTimes.sunrise)) {
                    let currentTime = new Date(sunTimes.sunrise);
                    while (currentTime <= sunTimes.sunset) {
                        let pos = SunCalc.getPosition(currentTime, userLat, userLon);
                        if (pos.altitude > (Math.PI / 2) - 0.01) {
                            const pastPos = SunCalc.getPosition(new Date(currentTime.getTime() - 60000), userLat, userLon);
                            pos.azimuth = pastPos.azimuth;
                        }

                        if (pos.altitude > MIN_ALTITUDE_RAD) {
                            const offset = (heightInFeet / Math.tan(pos.altitude)) * scale;
                            const shadowX = 100 + offset * Math.sin(pos.azimuth);
                            const shadowY = 100 - offset * Math.cos(pos.azimuth);
                            
                            const rotationRad = pos.azimuth;
                            
                            const stepData = {
                                center: { x: shadowX, y: shadowY },
                                rx: radiusScaled,
                                ry: radiusScaled / Math.sin(pos.altitude),
                                rotationRad: rotationRad 
                            };
                            shadowSteps.push(stepData);
                            const currentMinutes = currentTime.getHours() * 60 + currentTime.getMinutes();
                            dailySunPath.push({ minutes: currentMinutes, center: stepData.center });
                        }
                        currentTime.setMinutes(currentTime.getMinutes() + stepMinutes);
                    }
                }
                
                if (shadowSteps.length > 2) {
                    const leftPoints = [];
                    const rightPoints = [];

                    for (let i = 0; i < shadowSteps.length; i++) {
                        const step = shadowSteps[i];
                        
                        let tangentDx, tangentDy;
                        if (i === 0) {
                            tangentDx = shadowSteps[i + 1].center.x - step.center.x;
                            tangentDy = shadowSteps[i + 1].center.y - step.center.y;
                        } else if (i === shadowSteps.length - 1) {
                            tangentDx = step.center.x - shadowSteps[i - 1].center.x;
                            tangentDy = step.center.y - shadowSteps[i - 1].center.y;
                        } else {
                            tangentDx = shadowSteps[i + 1].center.x - shadowSteps[i - 1].center.x;
                            tangentDy = shadowSteps[i + 1].center.y - shadowSteps[i - 1].center.y;
                        }

                        const nx = -tangentDy;
                        const ny = tangentDx;

                        let maxDot = -Infinity;
                        let minDot = Infinity;
                        let pLeft, pRight;

                        for (let j = 0; j < 360; j += 1) {
                            const angleRad = j * (Math.PI / 180);
                            const x_rot = step.rx * Math.cos(angleRad);
                            const y_rot = step.ry * Math.sin(angleRad);
                            
                            const x = step.center.x + x_rot * Math.cos(step.rotationRad) - y_rot * Math.sin(step.rotationRad);
                            const y = step.center.y + x_rot * Math.sin(step.rotationRad) + y_rot * Math.cos(step.rotationRad);
                            
                            const dot = (x - step.center.x) * nx + (y - step.center.y) * ny;
                            
                            if (dot > maxDot) { maxDot = dot; pRight = {x, y}; }
                            if (dot < minDot) { minDot = dot; pLeft = {x, y}; }
                        }
                        if (pLeft) leftPoints.push(pLeft);
                        if (pRight) rightPoints.push(pRight);
                    }

                    if (leftPoints.length > 1 && rightPoints.length > 1) {
                        const rightPointsReversed = rightPoints.reverse();
                        const pathD = "M" + leftPoints.map(p => `${p.x.toFixed(2)},${p.y.toFixed(2)}`).join(" L ")
                                      + " L " + rightPointsReversed.map(p => `${p.x.toFixed(2)},${p.y.toFixed(2)}`).join(" L ")
                                      + " Z";
                        shadowPath.setAttribute('d', pathD);
                    } else {
                         shadowPath.setAttribute('d', '');
                    }

                } else {
                     shadowPath.setAttribute('d', '');
                }

                if (sunPosition.altitude < MIN_ALTITUDE_RAD) {
                    sunIndicator.classList.add('hidden');
                    nightMessage.classList.remove('hidden');
                    shadowEllipseSVG.classList.add('hidden');
                    centerPosText.textContent = '';
                    shadeDimsText.textContent = '';
                    return;
                }
                
                sunIndicator.classList.remove('hidden');
                const sunDist = ( (Math.PI / 2) - sunPosition.altitude) / (Math.PI / 2) * 100;
                const sunX = 100 - sunDist * Math.sin(sunPosition.azimuth);
                const sunY = 100 + sunDist * Math.cos(sunPosition.azimuth);

                sunIndicator.setAttribute('cx', sunX);
                sunIndicator.setAttribute('cy', sunY);

                nightMessage.classList.add('hidden');
                shadowEllipseSVG.classList.remove('hidden');
            
                const shadowOffset = (heightInFeet / Math.tan(sunPosition.altitude)) * scale;
                let shadowX = 100 + shadowOffset * Math.sin(sunPosition.azimuth);
                let shadowY = 100 - shadowOffset * Math.cos(sunPosition.azimuth);

                const elongatedRadius = radiusScaled / Math.sin(sunPosition.altitude);
                const rotationRad = sunPosition.azimuth;
                const rotationDegrees = rotationRad * (180 / Math.PI);

                shadowEllipseSVG.setAttribute('cx', shadowX);
                shadowEllipseSVG.setAttribute('cy', shadowY);
                shadowEllipseSVG.setAttribute('rx', radiusScaled);
                shadowEllipseSVG.setAttribute('ry', elongatedRadius);
                shadowEllipseSVG.setAttribute('transform', `rotate(${rotationDegrees} ${shadowX} ${shadowY})`);
                
                const shortAxisFeet = diameterInFeet;
                const longAxisFeet = diameterInFeet / Math.sin(sunPosition.altitude);
                
                const offsetEastWest_feet = (shadowX - 100) / scale;
                const offsetNorthSouth_feet = -(shadowY - 100) / scale;
                
                if (currentUnitSystem === 'imperial') {
                    shadeDimsText.textContent = `Shade Area: ${longAxisFeet.toFixed(1)}' x ${shortAxisFeet.toFixed(1)}'`;
                    const ewText = `${Math.abs(offsetEastWest_feet).toFixed(1)}' ${offsetEastWest_feet >= 0 ? 'E' : 'W'}`;
                    const nsText = `${Math.abs(offsetNorthSouth_feet).toFixed(1)}' ${offsetNorthSouth_feet >= 0 ? 'N' : 'S'}`;
                    centerPosText.textContent = `Center of Shade: ${nsText} & ${ewText}`;
                } else { // metric
                    const shortAxisMeters = shortAxisFeet * FEET_TO_METERS;
                    const longAxisMeters = longAxisFeet * FEET_TO_METERS;
                    const offsetEastWest_meters = offsetEastWest_feet * FEET_TO_METERS;
                    const offsetNorthSouth_meters = offsetNorthSouth_feet * FEET_TO_METERS;

                    shadeDimsText.textContent = `Shade Area: ${longAxisMeters.toFixed(1)}m x ${shortAxisMeters.toFixed(1)}m`;
                    const ewText = `${Math.abs(offsetEastWest_meters).toFixed(1)}m ${offsetEastWest_meters >= 0 ? 'E' : 'W'}`;
                    const nsText = `${Math.abs(offsetNorthSouth_meters).toFixed(1)}m ${offsetNorthSouth_meters >= 0 ? 'N' : 'S'}`;
                    centerPosText.textContent = `Center of Shade: ${nsText} & ${ewText}`;
                }
            }

            function getSVGCoords(e) {
                const pt = svg.createSVGPoint();
                if (e.touches) {
                    pt.x = e.touches[0].clientX;
                    pt.y = e.touches[0].clientY;
                } else {
                    pt.x = e.clientX;
                    pt.y = e.clientY;
                }
                return pt.matrixTransform(svg.getScreenCTM().inverse());
            }

            function findClosestTime(pos) {
                if (dailySunPath.length === 0) return 720; 

                let closest = null;
                let minDistance = Infinity;

                dailySunPath.forEach(point => {
                    const dx = point.center.x - pos.x;
                    const dy = point.center.y - pos.y;
                    const distance = dx * dx + dy * dy;
                    if (distance < minDistance) {
                        minDistance = distance;
                        closest = point;
                    }
                });
                return closest ? closest.minutes : 720;
            }

            function startDrag(e) {
                e.preventDefault();
                isDragging = true;
            }

            function drag(e) {
                if (!isDragging) return;
                e.preventDefault();
                const coords = getSVGCoords(e);

                coords.x = Math.max(0, Math.min(VIEWBOX_SIZE, coords.x));
                coords.y = Math.max(0, Math.min(VIEWBOX_SIZE, coords.y));

                const newTimeInMinutes = findClosestTime(coords);
                
                const hours = Math.floor(newTimeInMinutes / 60);
                const minutes = Math.round(newTimeInMinutes % 60);
                timeInputBox.value = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
                
                calculateAndDraw();
            }
            
            function endDrag() {
                isDragging = false;
            }

            function getLocation() {
                loader.style.display = 'flex';
                errorMessage.classList.add('hidden');
                latInput.disabled = true;
                lonInput.disabled = true;
                if (navigator.geolocation) {
                     navigator.geolocation.getCurrentPosition(
                         (position) => {
                             latInput.value = position.coords.latitude.toFixed(4);
                             lonInput.value = position.coords.longitude.toFixed(4);
                             loader.style.display = 'none';
                             latInput.disabled = false;
                             lonInput.disabled = false;
                             calculateAndDraw();
                         },
                         () => handleLocationError("Could not get location. Using default.")
                     );
                } else {
                    handleLocationError("Geolocation not supported. Using default.");
                }
            }

            function handleLocationError(message) {
                 latInput.value = (37.7749).toFixed(4);
                 lonInput.value = (-122.4194).toFixed(4);
                 errorMessage.textContent = message;
                 errorMessage.classList.remove('hidden');
                 loader.style.display = 'none';
                 latInput.disabled = false;
                 lonInput.disabled = false;
                 calculateAndDraw();
            }

            dateInput.addEventListener('input', () => {
                populateTimezonePicker();
                calculateAndDraw();
            });

            [heightInput, diameterInput, latInput, lonInput, timezonePicker, timeInputBox].forEach(el => {
                if (el) { 
                    el.addEventListener('input', calculateAndDraw);
                }
            });
            
            shadowEllipseSVG.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', endDrag);
            shadowEllipseSVG.addEventListener('touchstart', startDrag, { passive: false });
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('touchend', endDrag);

            unitImperialBtn.addEventListener('click', () => setUnitSystem('imperial'));
            unitMetricBtn.addEventListener('click', () => setUnitSystem('metric'));

            dateResetBtn.addEventListener('click', () => {
                dateInput.value = dayjs().format('YYYY-MM-DD');
                dateInput.dispatchEvent(new Event('input')); 
            });

            timeResetBtn.addEventListener('click', () => {
                const now = dayjs();
                timeInputBox.value = now.format('HH:mm');
                timezonePicker.value = dayjs.tz.guess();
                calculateAndDraw();
            });
            
            timezoneResetBtn.addEventListener('click', () => {
                timezonePicker.value = dayjs.tz.guess();
                calculateAndDraw();
            });

            getLocationBtn.addEventListener('click', getLocation);

            function initialize() {
                const now = dayjs();
                timeInputBox.value = now.format('HH:mm');
                dateInput.value = now.format('YYYY-MM-DD');

                populateTimezonePicker();

                if (screen.orientation && typeof screen.orientation.lock === 'function') {
                    try {
                        screen.orientation.lock('portrait-primary');
                    } catch (e) {
                        console.warn("Could not lock screen orientation:", e);
                    }
                }
                
                getLocation();
            }

            initialize();
        });
    </script>
</body>
</html>



