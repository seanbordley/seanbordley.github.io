<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shade Finder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/suncalc/1.8.0/suncalc.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/dayjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/utc.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/timezone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .slider-thumb::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 2.5vmin;
            height: 2.5vmin;
            background: #3b82f6;
            cursor: pointer;
            border-radius: 50%;
            border: 0.2vmin solid white;
            box-shadow: 0 0 0.5vmin rgba(0,0,0,0.2);
        }
        .slider-thumb::-moz-range-thumb {
            width: 2.5vmin;
            height: 2.5vmin;
            background: #3b82f6;
            cursor: pointer;
            border-radius: 50%;
            border: 0.2vmin solid white;
            box-shadow: 0 0 0.5vmin rgba(0,0,0,0.2);
        }
        .loader {
            border: 0.5vmin solid #f3f3f3;
            border-top: 0.5vmin solid #3b82f6;
            border-radius: 50%;
            width: 5vmin;
            height: 5vmin;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        input:disabled {
            background-color: #e5e7eb;
            cursor: not-allowed;
        }
        .dark input:disabled {
            background-color: #4b5563;
        }
        /* Hide number input arrows */
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type=number] {
            -moz-appearance: textfield;
        }
        .unit-toggle {
            background-color: transparent;
            transition: background-color 0.2s;
        }
        .active-unit {
            background-color: #3b82f6; /* blue-500 */
            color: white;
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 flex items-center justify-center min-h-screen p-2">
    <div class="w-full max-w-md mx-auto bg-white dark:bg-gray-800 rounded-2xl shadow-2xl p-3 space-y-2">
        <!-- Header -->
        <div class="text-center">
            <h1 class="text-xl font-bold text-blue-600 dark:text-blue-400">Shade Finder</h1>
            <p class="text-sm text-gray-500 dark:text-gray-400">Plan your perfect spot in the shade.</p>
        </div>

        <!-- Visualization -->
        <div class="relative w-full aspect-square bg-green-100 dark:bg-green-900/50 rounded-lg overflow-hidden border-2 border-gray-200 dark:border-gray-700">
             <svg id="sky" viewBox="0 0 200 200" class="absolute inset-0 w-full h-full">
                <!-- Compass Rose -->
                <text x="96" y="15" font-size="8" fill="currentColor" class="opacity-50 font-semibold">N</text>
                <text x="96" y="190" font-size="8" fill="currentColor" class="opacity-50 font-semibold">S</text>
                <text x="10" y="104" font-size="8" fill="currentColor" class="opacity-50 font-semibold">W</text>
                <text x="182" y="104" font-size="8" fill="currentColor" class="opacity-50 font-semibold">E</text>
                <line x1="100" y1="18" x2="100" y2="25" stroke="currentColor" stroke-width="0.5" class="opacity-50"/>
                <line x1="100" y1="182" x2="100" y2="175" stroke="currentColor" stroke-width="0.5" class="opacity-50"/>
                <line x1="18" y1="100" x2="25" y2="100" stroke="currentColor" stroke-width="0.5" class="opacity-50"/>
                <line x1="182" y1="100" x2="175" y2="100" stroke="currentColor" stroke-width="0.5" class="opacity-50"/>
                
                <!-- Shade Dimensions Text -->
                <text id="shade-dims-text" x="100" y="25" font-size="7" fill="currentColor" text-anchor="middle" class="font-semibold"></text>

                <!-- Shade Path -->
                <path id="shadow-path" fill="#3b82f6" fill-opacity="0.2" />
                
                <!-- Distance Overlay -->
                <g id="distance-overlay" class="opacity-80">
                    <line id="ew-line" x1="100" y1="100" x2="150" y2="100" stroke="currentColor" stroke-width="1" stroke-dasharray="2,2" />
                    <line id="ns-line" x1="150" y1="100" x2="150" y2="150" stroke="currentColor" stroke-width="1" stroke-dasharray="2,2" />
                    <text id="ew-text" x="125" y="95" font-size="7" fill="currentColor" text-anchor="middle" class="font-semibold">0 ft</text>
                    <text id="ns-text" x="155" y="125" font-size="7" fill="currentColor" text-anchor="start" dominant-baseline="middle" class="font-semibold">0 ft</text>
                </g>

                <!-- Shadow -->
                <ellipse id="shadow" cx="100" cy="100" rx="20" ry="20" fill="#3b82f6" fill-opacity="0.5" stroke="#3b82f6" stroke-width="1"/>
                <!-- Umbrella -->
                <circle id="umbrella" cx="100" cy="100" r="20" fill="rgb(156 163 175 / 0.5)" stroke="rgb(107 114 128)" stroke-width="1.5"/>
            </svg>
            <div id="night-message" class="absolute inset-0 bg-black/50 flex items-center justify-center text-white text-lg font-semibold hidden">
                <p>It's nighttime!</p>
            </div>
             <div id="loader" class="absolute inset-0 bg-white/70 dark:bg-gray-800/70 flex items-center justify-center">
                <div class="loader"></div>
            </div>
        </div>

        <!-- Legend -->
        <div class="flex justify-center items-center space-x-4 text-xs text-gray-600 dark:text-gray-400 pt-1">
            <div class="flex items-center space-x-1.5">
                <span class="w-3 h-3 rounded-full bg-gray-400/50 border border-gray-500"></span>
                <span>Umbrella</span>
            </div>
            <div class="flex items-center space-x-1.5">
                <span class="w-3 h-3 rounded-full bg-blue-500/50 border border-blue-600"></span>
                <span>Shade</span>
            </div>
             <div class="flex items-center space-x-1.5">
                <span class="w-3 h-3 rounded-full bg-blue-500/20"></span>
                <span>Day's Shade Path</span>
            </div>
        </div>
        
        <!-- Controls -->
        <div class="space-y-2 pt-1">
            <!-- Location Section -->
            <div id="location-section" class="p-2 bg-gray-50 dark:bg-gray-700/50 rounded-lg">
                 <div class="grid grid-cols-3 items-center">
                    <label class="text-xs font-medium text-gray-700 dark:text-gray-300">Location</label>
                    <div class="text-center">
                        <button id="getLocationBtn" class="text-xs text-blue-500 hover:underline">Current</button>
                    </div>
                    <div></div>
                </div>
                 <div class="flex flex-wrap items-center justify-between gap-y-1 text-sm mt-1">
                    <div class="flex items-center gap-2">
                        <label for="lat" class="text-xs font-medium text-gray-600 dark:text-gray-400">Latitude</label>
                        <input type="number" id="lat" step="0.0001" class="w-24 p-1 rounded border bg-white dark:bg-gray-600 border-gray-300 dark:border-gray-500 text-sm">
                    </div>
                    <div class="flex items-center gap-2">
                        <label for="lon" class="text-xs font-medium text-gray-600 dark:text-gray-400">Longitude</label>
                        <input type="number" id="lon" step="0.0001" class="w-24 p-1 rounded border bg-white dark:bg-gray-600 border-gray-300 dark:border-gray-500 text-sm">
                    </div>
                 </div>
                 <p id="error-message" class="text-red-500 text-xs hidden text-center pt-1"></p>
            </div>
             <!-- Date -->
             <div>
                <div class="grid grid-cols-3 items-center">
                    <label for="date" class="text-xs font-medium text-gray-700 dark:text-gray-300">Date</label>
                    <div class="text-center">
                        <button id="date-reset-btn" class="text-xs text-blue-500 hover:underline">Today</button>
                    </div>
                    <div></div>
                </div>
                <input id="date" type="date" class="w-full mt-1 p-1 rounded-md border bg-white dark:bg-gray-600 border-gray-300 dark:border-gray-500 text-sm">
            </div>
            <!-- Timezone -->
             <div>
                <div class="grid grid-cols-3 items-center">
                    <label for="timezone-picker" class="text-xs font-medium text-gray-700 dark:text-gray-300">Time Zone</label>
                    <div class="text-center">
                        <button id="timezone-reset-btn" class="text-xs text-blue-500 hover:underline">Auto-detect</button>
                    </div>
                    <div></div>
                </div>
                <select id="timezone-picker" class="w-full mt-1 p-1 rounded-md border bg-white dark:bg-gray-600 border-gray-300 dark:border-gray-500 text-sm"></select>
            </div>
            <!-- Umbrella Specs -->
            <div class="grid grid-cols-2 gap-2">
                <div>
                    <div class="flex justify-between items-center">
                        <label for="height" id="height-label" class="text-xs font-medium text-gray-700 dark:text-gray-300">Height (ft)</label>
                        <div class="flex items-center text-xs border border-gray-300 dark:border-gray-500 rounded-md overflow-hidden">
                            <button id="height-unit-ft" class="px-2 py-0.5 unit-toggle active-unit">ft</button>
                            <button id="height-unit-m" class="px-2 py-0.5 unit-toggle">m</button>
                        </div>
                    </div>
                    <input id="height" type="number" value="7" step="0.1" class="w-full mt-1 p-1 rounded-md border bg-white dark:bg-gray-600 border-gray-300 dark:border-gray-500 text-sm">
                </div>
                <div>
                    <div class="flex justify-between items-center">
                        <label for="diameter" id="diameter-label" class="text-xs font-medium text-gray-700 dark:text-gray-300">Diameter (ft)</label>
                        <div class="flex items-center text-xs border border-gray-300 dark:border-gray-500 rounded-md overflow-hidden">
                            <button id="diameter-unit-ft" class="px-2 py-0.5 unit-toggle active-unit">ft</button>
                            <button id="diameter-unit-m" class="px-2 py-0.5 unit-toggle">m</button>
                        </div>
                    </div>
                    <input id="diameter" type="number" value="9" step="0.1" class="w-full mt-1 p-1 rounded-md border bg-white dark:bg-gray-600 border-gray-300 dark:border-gray-500 text-sm">
                </div>
            </div>
            <!-- Time -->
            <div>
                 <div class="grid grid-cols-3 items-center text-xs font-medium text-gray-700 dark:text-gray-300">
                    <label for="time">Time</label>
                    <div class="text-center">
                         <button id="time-reset-btn" class="text-xs text-blue-500 hover:underline">Now</button>
                    </div>
                    <div class="text-right">
                        <span id="timeValue" class="font-bold text-blue-600 dark:text-blue-400 text-sm">12:00 PM</span>
                    </div>
                </div>
                <input id="time" type="range" min="0" max="1439" value="720" step="15" class="w-full h-2 mt-1 bg-gray-200 dark:bg-gray-600 rounded-lg appearance-none cursor-pointer slider-thumb">
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            dayjs.extend(window.dayjs_plugin_utc);
            dayjs.extend(window.dayjs_plugin_timezone);

            const heightInput = document.getElementById('height');
            const diameterInput = document.getElementById('diameter');
            const timeSlider = document.getElementById('time');
            const timeValue = document.getElementById('timeValue');
            const dateInput = document.getElementById('date');
            
            const umbrellaSVG = document.getElementById('umbrella');
            const shadowSVG = document.getElementById('shadow');
            const shadowPath = document.getElementById('shadow-path');
            const nightMessage = document.getElementById('night-message');
            
            const latInput = document.getElementById('lat');
            const lonInput = document.getElementById('lon');
            const getLocationBtn = document.getElementById('getLocationBtn');

            const loader = document.getElementById('loader');
            const errorMessage = document.getElementById('error-message');
            
            const distanceOverlay = document.getElementById('distance-overlay');
            const nsLine = document.getElementById('ns-line');
            const ewLine = document.getElementById('ew-line');
            const nsText = document.getElementById('ns-text');
            const ewText = document.getElementById('ew-text');
            const shadeDimsText = document.getElementById('shade-dims-text');

            const heightUnitFt = document.getElementById('height-unit-ft');
            const heightUnitM = document.getElementById('height-unit-m');
            const heightLabel = document.getElementById('height-label');
            const diameterUnitFt = document.getElementById('diameter-unit-ft');
            const diameterUnitM = document.getElementById('diameter-unit-m');
            const diameterLabel = document.getElementById('diameter-label');
            
            const dateResetBtn = document.getElementById('date-reset-btn');
            const timeResetBtn = document.getElementById('time-reset-btn');
            const timezonePicker = document.getElementById('timezone-picker');
            const timezoneResetBtn = document.getElementById('timezone-reset-btn');

            const VIEWBOX_SIZE = 200;
            const FEET_TO_METERS = 0.3048;
            const METERS_TO_FEET = 3.28084;
            const MIN_ALTITUDE_RAD = 0.0872665; // 5 degrees in radians


            // --- UI UPDATE FUNCTIONS ---
            function updateSliderValue(slider, display) {
                const totalMinutes = parseInt(slider.value);
                const hours = Math.floor(totalMinutes / 60) % 24;
                const minutes = totalMinutes % 60;
                const ampm = hours >= 12 ? 'PM' : 'AM';
                const displayHours = hours % 12 === 0 ? 12 : hours % 12;
                const displayMinutes = minutes < 10 ? '0' + minutes : minutes;
                display.textContent = `${displayHours}:${displayMinutes} ${ampm}`;
            }
            
            function getCombinedDate() {
                const dateStr = dateInput.value;
                if (!dateStr) return new Date();

                const totalMinutes = parseInt(timeSlider.value);
                const hours = Math.floor(totalMinutes / 60);
                const minutes = totalMinutes % 60;
                
                const timeStr = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
                const isoStr = `${dateStr}T${timeStr}`;
                const selectedTimezone = timezonePicker.value;

                return dayjs.tz(isoStr, selectedTimezone).toDate();
            }

            function setUnit(type, unit) {
                const ftBtn = document.getElementById(`${type}-unit-ft`);
                const mBtn = document.getElementById(`${type}-unit-m`);
                const label = document.getElementById(`${type}-label`);
                const input = document.getElementById(type);
                let currentVal = parseFloat(input.value);

                if (isNaN(currentVal)) return;

                if (unit === 'ft' && !ftBtn.classList.contains('active-unit')) {
                    ftBtn.classList.add('active-unit');
                    mBtn.classList.remove('active-unit');
                    label.textContent = `${type.charAt(0).toUpperCase() + type.slice(1)} (ft)`;
                    input.value = (currentVal * METERS_TO_FEET).toFixed(1);

                } else if (unit === 'm' && !mBtn.classList.contains('active-unit')) {
                    mBtn.classList.add('active-unit');
                    ftBtn.classList.remove('active-unit');
                    label.textContent = `${type.charAt(0).toUpperCase() + type.slice(1)} (m)`;
                    input.value = (currentVal * FEET_TO_METERS).toFixed(2);
                }
                calculateAndDraw();
            }
            
            // --- CORE CALCULATION & DRAWING ---
            function calculateAndDraw() {
                const userLat = parseFloat(latInput.value);
                const userLon = parseFloat(lonInput.value);
                if (isNaN(userLat) || isNaN(userLon)) return;

                let heightVal = parseFloat(heightInput.value);
                const heightInFeet = heightUnitM.classList.contains('active-unit') ? heightVal * METERS_TO_FEET : heightVal;
                
                let diameterVal = parseFloat(diameterInput.value);
                const diameterInFeet = diameterUnitM.classList.contains('active-unit') ? diameterVal * METERS_TO_FEET : diameterVal;

                if (isNaN(heightInFeet) || isNaN(diameterInFeet)) return;

                const maxPossibleShadow = (heightInFeet / Math.tan(MIN_ALTITUDE_RAD));
                const totalPathWidthGuess = diameterInFeet * 2 + maxPossibleShadow;
                const scale = VIEWBOX_SIZE / totalPathWidthGuess;

                const radiusInFeet = diameterInFeet / 2;
                const radiusScaled = radiusInFeet * scale;
                
                umbrellaSVG.setAttribute('r', radiusScaled);
                
                const now = getCombinedDate();
                const sunPosition = SunCalc.getPosition(now, userLat, userLon);
                
                // --- Accurately draw the entire day's shade path ---
                const sunTimes = SunCalc.getTimes(now, userLat, userLon);
                const shadowSteps = [];
                const stepMinutes = 15;
                
                if (sunTimes.sunrise instanceof Date && !isNaN(sunTimes.sunrise)) {
                    let currentTime = new Date(sunTimes.sunrise);
                    while (currentTime <= sunTimes.sunset) {
                        const pos = SunCalc.getPosition(currentTime, userLat, userLon);
                        if (pos.altitude > MIN_ALTITUDE_RAD) {
                            const offset = (heightInFeet / Math.tan(pos.altitude)) * scale;
                            const cartesianAzimuth = pos.azimuth + Math.PI / 2;
                            const shadowAngle = cartesianAzimuth + Math.PI;
                            
                            shadowSteps.push({
                                center: {
                                    x: 100 + offset * Math.cos(shadowAngle),
                                    y: 100 - offset * Math.sin(shadowAngle)
                                },
                                rx: radiusScaled / Math.sin(pos.altitude),
                                ry: radiusScaled,
                                rotationRad: -cartesianAzimuth
                            });
                        }
                        currentTime.setMinutes(currentTime.getMinutes() + stepMinutes);
                    }
                }
                
                if (shadowSteps.length > 2) {
                    const leftPoints = [];
                    const rightPoints = [];

                    for (let i = 0; i < shadowSteps.length; i++) {
                        const step = shadowSteps[i];
                        
                        // Determine path direction to find the normal
                        const prevCenter = (i > 0) ? shadowSteps[i-1].center : step.center;
                        const nextCenter = (i < shadowSteps.length - 1) ? shadowSteps[i+1].center : step.center;
                        const dx = nextCenter.x - prevCenter.x;
                        const dy = nextCenter.y - prevCenter.y;
                        
                        // Normal vector to the path's direction
                        const nx = -dy;
                        const ny = dx;

                        let maxDot = -Infinity;
                        let minDot = Infinity;
                        let pLeft, pRight;

                        // Sample points on the ellipse to find the ones most perpendicular to the path
                        for (let j = 0; j < 360; j += 15) {
                            const angleRad = j * (Math.PI / 180);
                            const x_rot = step.rx * Math.cos(angleRad);
                            const y_rot = step.ry * Math.sin(angleRad);
                            
                            const x = step.center.x + x_rot * Math.cos(step.rotationRad) - y_rot * Math.sin(step.rotationRad);
                            const y = step.center.y + x_rot * Math.sin(step.rotationRad) + y_rot * Math.cos(step.rotationRad);
                            
                            const dot = (x - step.center.x) * nx + (y - step.center.y) * ny;
                            
                            if (dot > maxDot) {
                                maxDot = dot;
                                pRight = {x, y};
                            }
                            if (dot < minDot) {
                                minDot = dot;
                                pLeft = {x, y};
                            }
                        }
                        if(pLeft) leftPoints.push(pLeft);
                        if(pRight) rightPoints.push(pRight);
                    }

                    if (leftPoints.length > 1 && rightPoints.length > 1) {
                        const rightPointsReversed = rightPoints.reverse();
                        const pathD = "M" + leftPoints.map(p => `${p.x.toFixed(2)},${p.y.toFixed(2)}`).join(" L ")
                                    + " L " + rightPointsReversed.map(p => `${p.x.toFixed(2)},${p.y.toFixed(2)}`).join(" L ")
                                    + " Z";
                        shadowPath.setAttribute('d', pathD);
                    } else {
                         shadowPath.setAttribute('d', '');
                    }

                } else {
                    shadowPath.setAttribute('d', '');
                }


                // --- Draw Current Shade & Position ---
                if (sunPosition.altitude <= 0) {
                    nightMessage.classList.remove('hidden');
                    shadowSVG.classList.add('hidden');
                    distanceOverlay.classList.add('hidden');
                    shadeDimsText.classList.add('hidden');
                    return;
                }
                
                nightMessage.classList.add('hidden');
                shadowSVG.classList.remove('hidden');
                distanceOverlay.classList.remove('hidden');
                shadeDimsText.classList.remove('hidden');

                const shadowOffset = (heightInFeet / Math.tan(sunPosition.altitude)) * scale;
                const cartesianAzimuth = sunPosition.azimuth + Math.PI / 2;
                const shadowAngle = cartesianAzimuth + Math.PI;
                
                const shadowX = 100 + shadowOffset * Math.cos(shadowAngle);
                const shadowY = 100 - shadowOffset * Math.sin(shadowAngle);
                
                const elongatedRadius = radiusScaled / Math.sin(sunPosition.altitude);
                const rotationDegrees = -cartesianAzimuth * (180 / Math.PI);

                shadowSVG.setAttribute('cx', shadowX);
                shadowSVG.setAttribute('cy', shadowY);
                shadowSVG.setAttribute('rx', elongatedRadius);
                shadowSVG.setAttribute('ry', radiusScaled);
                shadowSVG.setAttribute('transform', `rotate(${rotationDegrees} ${shadowX} ${shadowY})`);
                
                // --- Display Shade Dimensions ---
                const shortAxisFeet = diameterInFeet;
                const longAxisFeet = diameterInFeet / Math.sin(sunPosition.altitude);
                const shortAxisMeters = shortAxisFeet * FEET_TO_METERS;
                const longAxisMeters = longAxisFeet * FEET_TO_METERS;
                
                shadeDimsText.textContent = `Shade: ${longAxisFeet.toFixed(1)}' x ${shortAxisFeet.toFixed(1)}' (${longAxisMeters.toFixed(1)}m x ${shortAxisMeters.toFixed(1)}m)`;

                // --- Display Distance Overlay ---
                const offsetEastWest_feet = (shadowX - 100) / scale;
                const offsetNorthSouth_feet = -(shadowY - 100) / scale;
                const LABEL_PADDING = 4;

                const offsetEastWest_meters = offsetEastWest_feet * FEET_TO_METERS;
                const offsetNorthSouth_meters = offsetNorthSouth_feet * FEET_TO_METERS;

                ewLine.setAttribute('x1', 100);
                ewLine.setAttribute('y1', 100);
                ewLine.setAttribute('x2', shadowX);
                ewLine.setAttribute('y2', 100);

                nsLine.setAttribute('x1', shadowX);
                nsLine.setAttribute('y1', 100);
                nsLine.setAttribute('x2', shadowX);
                nsLine.setAttribute('y2', shadowY);
                
                const ewDistFt = Math.abs(offsetEastWest_feet);
                const ewDistM = Math.abs(offsetEastWest_meters);
                const ewTextContent = `${ewDistFt.toFixed(1)}ft (${ewDistM.toFixed(1)}m) ${offsetEastWest_feet >= 0 ? 'E' : 'W'}`;
                ewText.setAttribute('x', (100 + shadowX) / 2);
                ewText.setAttribute('y', 100 - radiusScaled - LABEL_PADDING);
                ewText.setAttribute('dominant-baseline', 'auto');
                ewText.textContent = ewTextContent;

                const nsDistFt = Math.abs(offsetNorthSouth_feet);
                const nsDistM = Math.abs(offsetNorthSouth_meters);
                const nsTextContent = `${nsDistFt.toFixed(1)}ft (${nsDistM.toFixed(1)}m) ${offsetNorthSouth_feet >= 0 ? 'N' : 'S'}`;
                const textXOffset = (offsetEastWest_feet >= 0 ? 1 : -1) * (radiusScaled + LABEL_PADDING);
                const textAnchor = offsetEastWest_feet >= 0 ? 'start' : 'end';
                nsText.setAttribute('x', shadowX + textXOffset);
                nsText.setAttribute('y', (100 + shadowY) / 2);
                nsText.setAttribute('text-anchor', textAnchor);
                nsText.textContent = nsTextContent;
            }

            // --- GEOLOCATION ---
            function getLocation() {
                loader.style.display = 'flex';
                errorMessage.classList.add('hidden');
                latInput.disabled = true;
                lonInput.disabled = true;
                handleLocationError("Showing preset location.");
            }

            function handleLocationError(message) {
                 latInput.value = (37.5629).toFixed(4);
                 lonInput.value = (-122.3255).toFixed(4);
                 errorMessage.textContent = message;
                 loader.style.display = 'none';
                 latInput.disabled = false;
                 lonInput.disabled = false;
                 calculateAndDraw();
            }

            // --- EVENT LISTENERS ---
            [heightInput, diameterInput, timeSlider, dateInput, latInput, lonInput, timezonePicker].forEach(el => {
                el.addEventListener('input', calculateAndDraw);
            });
            timeSlider.addEventListener('input', () => updateSliderValue(timeSlider, timeValue));

            heightUnitFt.addEventListener('click', () => setUnit('height', 'ft'));
            heightUnitM.addEventListener('click', () => setUnit('height', 'm'));
            diameterUnitFt.addEventListener('click', () => setUnit('diameter', 'ft'));
            diameterUnitM.addEventListener('click', () => setUnit('diameter', 'm'));

            dateResetBtn.addEventListener('click', () => {
                dateInput.value = dayjs().format('YYYY-MM-DD');
                calculateAndDraw();
            });

            timeResetBtn.addEventListener('click', () => {
                const now = dayjs();
                const currentMinutes = now.hour() * 60 + now.minute();
                timeSlider.value = currentMinutes;
                timezonePicker.value = dayjs.tz.guess();
                updateSliderValue(timeSlider, timeValue);
                calculateAndDraw();
            });
            
            timezoneResetBtn.addEventListener('click', () => {
                timezonePicker.value = dayjs.tz.guess();
                calculateAndDraw();
            });

            getLocationBtn.addEventListener('click', () => {
                loader.style.display = 'flex';
                latInput.disabled = true;
                lonInput.disabled = true;
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            latInput.value = position.coords.latitude.toFixed(4);
                            lonInput.value = position.coords.longitude.toFixed(4);
                            loader.style.display = 'none';
                            latInput.disabled = false;
                            lonInput.disabled = false;
                            calculateAndDraw();
                        },
                        () => handleLocationError("Could not get location. Please enter manually.")
                    );
                } else {
                    handleLocationError("Geolocation not supported. Please enter manually.");
                }
            });

            // --- INITIALIZATION ---
            function initialize() {
                // Populate Timezone Picker
                const timezones = Intl.supportedValuesOf('timeZone');
                timezones.forEach(tz => {
                    const option = document.createElement('option');
                    option.value = tz;
                    option.textContent = tz.replace(/_/g, ' ');
                    timezonePicker.appendChild(option);
                });
                timezonePicker.value = dayjs.tz.guess();

                // Set initial values
                const initialTimeMinutes = 16 * 60; // 4:00 PM
                timeSlider.value = initialTimeMinutes;
                dateInput.value = '2025-09-03';
                
                updateSliderValue(timeSlider, timeValue);
                getLocation();
            }

            initialize();
        });
    </script>
</body>
</html>

