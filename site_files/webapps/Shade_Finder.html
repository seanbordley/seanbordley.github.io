<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shade Finder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/suncalc/1.8.0/suncalc.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/dayjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/utc.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/timezone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .loader {
            border: 0.5vmin solid #4a5568; /* gray-700 */
            border-top: 0.5vmin solid #4299e1; /* blue-400 */
            border-radius: 50%;
            width: 5vmin;
            height: 5vmin;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        input:disabled {
            background-color: #2d3748; /* gray-800 */
            cursor: not-allowed;
        }
        /* Hide number input arrows */
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type=number] {
            -moz-appearance: textfield;
        }
        .unit-toggle {
            background-color: transparent;
            transition: background-color 0.2s;
        }
        .active-unit {
            background-color: #3b82f6; /* blue-500 */
            color: white;
        }
        /* Hide the default icons on date/time inputs in WebKit browsers */
        input[type="time"]::-webkit-calendar-picker-indicator,
        input[type="date"]::-webkit-calendar-picker-indicator {
            display: none;
        }
        #shadow {
            cursor: grab;
        }
        #shadow:active {
            cursor: grabbing;
        }
    </style>
</head>
<body class="bg-black text-gray-300 flex items-center justify-center min-h-screen p-2">
    <div class="w-full max-w-md mx-auto space-y-2">
        <div class="text-center">
            <h1 class="font-bold text-blue-400" style="font-size: 6vmin;">Shade Finder</h1>
            <p class="text-gray-400" style="font-size: 2.25vmin;">Plan your perfect spot in the shade.</p>
        </div>

        <div class="relative w-full aspect-square bg-gray-800 rounded-lg overflow-hidden border-2 border-gray-700">
             <svg id="sky" viewBox="0 0 200 200" class="absolute inset-0 w-full h-full">
                  <g id="grid-overlay"></g>
                  <text x="96" y="15" fill="currentColor" class="opacity-50 font-semibold" style="font-size: 2vmin;">N</text>
                  <text x="96" y="190" fill="currentColor" class="opacity-50 font-semibold" style="font-size: 2vmin;">S</text>
                  <text x="10" y="104" fill="currentColor" class="opacity-50 font-semibold" style="font-size: 2vmin;">W</text>
                  <text x="182" y="104" fill="currentColor" class="opacity-50 font-semibold" style="font-size: 2vmin;">E</text>
                  <line x1="100" y1="18" x2="100" y2="25" stroke="currentColor" stroke-width="0.5" class="opacity-50"/>
                  <line x1="100" y1="182" x2="100" y2="175" stroke="currentColor" stroke-width="0.5" class="opacity-50"/>
                  <line x1="18" y1="100" x2="25" y2="100" stroke="currentColor" stroke-width="0.5" class="opacity-50"/>
                  <line x1="182" y1="100" x2="175" y2="100" stroke="currentColor" stroke-width="0.5" class="opacity-50"/>
                  
                  <g id="info-text-group" text-anchor="middle" fill="currentColor" class="font-semibold" style="font-size: 1vmin;">
                       <text id="shade-dims-text" x="100" y="25"></text>
                       <text id="center-pos-text" x="100" y="33"></text>
                  </g>
                  
                  <path id="shadow-path" fill="#3b82f6" fill-opacity="0.4" />
                  <g id="hourly-dots-group"></g>
                  
                  <ellipse id="shadow" cx="100" cy="100" rx="20" ry="20" fill="#3b82f6" fill-opacity="0.5" stroke="#3b82f6" stroke-width="1"/>
                  <circle id="umbrella" cx="100" cy="100" r="20" fill="rgb(156 163 175 / 0.5)" stroke="rgb(107 114 128)" stroke-width="1.5"/>

            </svg>
            <div id="night-message" class="absolute inset-0 bg-black/50 flex items-center justify-center text-white font-semibold hidden" style="font-size: 4vmin;">
                <p>It's Nighttime!</p>
            </div>
             <div id="loader" class="absolute inset-0 bg-gray-800/70 nightflex items-center justify-center">
                  <div class="loader"></div>
            </div>

            <div class="absolute bottom-2 left-2 grid grid-cols-[auto_1fr] gap-x-1 gap-y-1 items-center">
                <button id="getLocationBtn" title="Get Current Location" class="p-1 rounded-md bg-gray-900/70 backdrop-blur-sm hover:bg-gray-700">
                    <svg class="w-4 h-4 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                </button>
                <input type="number" id="lat" step="0.0001" class="bg-gray-900/70 backdrop-blur-sm rounded-md p-0.5 border-gray-600 w-full text-left" style="font-size: 1.75vmin;" placeholder="Lat:">
                
                <div class="w-4 h-4"></div> <!-- Spacer -->

                <input type="number" id="lon" step="0.0001" class="bg-gray-900/70 backdrop-blur-sm rounded-md p-0.5 border-gray-600 w-full text-left" style="font-size: 1.75vmin;" placeholder="Lon:">
            </div>

            <div class="absolute bottom-2 right-2 grid grid-cols-[auto_1fr] gap-x-1 gap-y-1 items-center">
                  <button id="date-reset-btn" title="Set to today" class="p-1 rounded-md bg-gray-900/70 backdrop-blur-sm hover:bg-gray-700">
                       <svg class="w-4 h-4 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                  </button>
                <input type="date" id="date" class="bg-gray-900/70 backdrop-blur-sm rounded-md p-0.5 border-gray-600 w-full" style="font-size: 1.75vmin;">

                  <button id="time-reset-btn" title="Set to current time" class="p-1 rounded-md bg-gray-900/70 backdrop-blur-sm hover:bg-gray-700">
                       <svg class="w-4 h-4 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                  </button>
                <input type="text" id="time-input-box" class="bg-gray-900/70 backdrop-blur-sm rounded-md px-1 py-0.5 border-gray-600 w-full" style="font-size: 1.75vmin;" pattern="([01]?[0-9]|2[0-3]):[0-5][0-9]" placeholder="HH:mm">
                
                  <button id="timezone-reset-btn" title="Auto-detect time zone" class="p-1 rounded-md bg-gray-900/70 backdrop-blur-sm hover:bg-gray-700">
                       <svg class="w-4 h-4 text-gray-300 transform rotate-90" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3.51 9h16.98M3.51 15h16.98M12 3a9 9 0 015.657 15.343"></path>
                        </svg>
                  </button>
                  <div class="w-full">
                       <select id="timezone-picker" class="bg-gray-900/70 backdrop-blur-sm rounded-md p-0.5 border-gray-600 w-auto" style="font-size: 1.75vmin;"></select>
                  </div>
            </div>
        </div>

        <div class="flex justify-center items-center flex-wrap gap-x-4 gap-y-1 text-gray-400 pt-1" style="font-size: 2.25vmin;">
            <div class="flex items-center space-x-1.5">
                <span class="w-3 h-3 rounded-full bg-gray-400/50 border border-gray-500"></span>
                <span>Umbrella</span>
            </div>
            <div class="flex items-center space-x-1.5">
                <span class="w-3 h-3 rounded-full bg-blue-500/50 border border-blue-600"></span>
                <span>Shade</span>
            </div>
             <div class="flex items-center space-x-1.5">
                <span class="w-3 h-3 rounded-full bg-blue-500/40"></span>
                <span>Day's Path</span>
            </div>
            <div class="flex items-center space-x-1.5">
                <span class="w-3 h-3 rounded-full" style="background-color: rgba(255, 255, 255, 0.7);"></span>
                <span>Projections</span>
            </div>
             <div class="flex items-center space-x-1.5">
                 <svg width="12" height="12" viewBox="0 0 12 12" class="opacity-100"><path d="M0 6 L12 6 M6 0 L6 12" stroke="currentColor" stroke-width="0.5"></path></svg>
                <span>2ft Grid</span>
            </div>
        </div>
        
        <div class="space-y-2 pt-1">
            <div class="grid grid-cols-2 gap-2">
                <div>
                    <div class="flex justify-between items-center">
                        <label for="height" id="height-label" class="font-medium text-gray-300" style="font-size: 2.25vmin;">Height (ft)</label>
                        <div class="flex items-center border border-gray-600 rounded-md overflow-hidden" style="font-size: 2.25vmin;">
                            <button id="height-unit-ft" class="px-2 py-0.5 unit-toggle active-unit">ft</button>
                            <button id="height-unit-m" class="px-2 py-0.5 unit-toggle">m</button>
                        </div>
                    </div>
                    <input id="height" type="number" value="5.5" step="0.1" class="w-full mt-1 p-1 rounded-md border bg-gray-700 border-gray-600" style="font-size: 2.25vmin;">
                </div>
                <div>
                    <div class="flex justify-between items-center">
                        <label for="diameter" id="diameter-label" class="font-medium text-gray-300" style="font-size: 2.25vmin;">Diameter (ft)</label>
                        <div class="flex items-center border border-gray-600 rounded-md overflow-hidden" style="font-size: 2.25vmin;">
                            <button id="diameter-unit-ft" class="px-2 py-0.5 unit-toggle active-unit">ft</button>
                            <button id="diameter-unit-m" class="px-2 py-0.5 unit-toggle">m</button>
                        </div>
                   </div>
                   <input id="diameter" type="number" value="5" step="0.1" class="w-full mt-1 p-1 rounded-md border bg-gray-700 border-gray-600" style="font-size: 2.25vmin;">
                </div>
            </div>
        </div>
         <p id="error-message" class="text-red-500 hidden text-center pt-1" style="font-size: 2.25vmin;"></p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            dayjs.extend(window.dayjs_plugin_utc);
            dayjs.extend(window.dayjs_plugin_timezone);

            const heightInput = document.getElementById('height');
            const diameterInput = document.getElementById('diameter');
            const timeInputBox = document.getElementById('time-input-box');
            const dateInput = document.getElementById('date');
            
            const svg = document.getElementById('sky');
            const umbrellaSVG = document.getElementById('umbrella');
            const shadowSVG = document.getElementById('shadow');
            const shadowPath = document.getElementById('shadow-path');
            const hourlyDotsGroup = document.getElementById('hourly-dots-group');
            const nightMessage = document.getElementById('night-message');
            const gridOverlay = document.getElementById('grid-overlay');
            
            const latInput = document.getElementById('lat');
            const lonInput = document.getElementById('lon');
            const getLocationBtn = document.getElementById('getLocationBtn');

            const loader = document.getElementById('loader');
            const errorMessage = document.getElementById('error-message');
            
            const centerPosText = document.getElementById('center-pos-text');
            const shadeDimsText = document.getElementById('shade-dims-text');

            const heightUnitFt = document.getElementById('height-unit-ft');
            const heightUnitM = document.getElementById('height-unit-m');
            const heightLabel = document.getElementById('height-label');
            const diameterUnitFt = document.getElementById('diameter-unit-ft');
            const diameterUnitM = document.getElementById('diameter-unit-m');
            const diameterLabel = document.getElementById('diameter-label');
            
            const dateResetBtn = document.getElementById('date-reset-btn');
            const timeResetBtn = document.getElementById('time-reset-btn');
            const timezonePicker = document.getElementById('timezone-picker');
            const timezoneResetBtn = document.getElementById('timezone-reset-btn');

            const VIEWBOX_SIZE = 200;
            const FEET_TO_METERS = 0.3048;
            const METERS_TO_FEET = 3.28084;
            const MIN_ALTITUDE_RAD = 0.0872665; // 5 degrees in radians

            let isDragging = false;
            let dailySunPath = [];
            
            function getCombinedDate() {
                const dateStr = dateInput.value;
                const timeStr = timeInputBox.value;
                if (!dateStr || !timeStr) return new Date();

                const isoStr = `${dateStr}T${timeStr}`;
                const selectedTimezone = timezonePicker.value;

                return dayjs.tz(isoStr, selectedTimezone).toDate();
            }

            function setUnit(type, unit) {
                const ftBtn = document.getElementById(`${type}-unit-ft`);
                const mBtn = document.getElementById(`${type}-unit-m`);
                const label = document.getElementById(`${type}-label`);
                const input = document.getElementById(type);
                let currentVal = parseFloat(input.value);

                if (isNaN(currentVal)) return;

                if (unit === 'ft' && !ftBtn.classList.contains('active-unit')) {
                    ftBtn.classList.add('active-unit');
                    mBtn.classList.remove('active-unit');
                    label.textContent = `${type.charAt(0).toUpperCase() + type.slice(1)} (ft)`;
                    input.value = (currentVal * METERS_TO_FEET).toFixed(1);

                } else if (unit === 'm' && !mBtn.classList.contains('active-unit')) {
                    mBtn.classList.add('active-unit');
                    ftBtn.classList.remove('active-unit');
                    label.textContent = `${type.charAt(0).toUpperCase() + type.slice(1)} (m)`;
                    input.value = (currentVal * FEET_TO_METERS).toFixed(2);
                }
                calculateAndDraw();
            }
            
            // --- TIMEZONE PICKER LOGIC ---
            function populateTimezonePicker() {
                const selectedDate = dateInput.value ? new Date(dateInput.value + 'T12:00:00Z') : new Date();
                const allTimezones = Intl.supportedValuesOf('timeZone');
                const currentSelectedTz = timezonePicker.value;
                timezonePicker.innerHTML = '';

                const tzMap = new Map();

                allTimezones.forEach(tz => {
                    try {
                        const formatter = new Intl.DateTimeFormat('en-US', {
                            timeZone: tz,
                            timeZoneName: 'short'
                        });
                        const parts = formatter.formatToParts(selectedDate);
                        const tzNamePart = parts.find(part => part.type === 'timeZoneName');

                        if (tzNamePart) {
                            tzMap.set(tz, `${tz.split('/').pop().replace(/_/g, ' ')} (${tzNamePart.value})`);
                        }
                    } catch (e) { /* Ignore invalid timezones */ }
                });
                
                const sortedTzs = [...tzMap.entries()].sort((a, b) => a[1].localeCompare(b[1]));

                sortedTzs.forEach(([value, text]) => {
                    const option = document.createElement('option');
                    option.value = value;
                    option.textContent = text;
                    timezonePicker.appendChild(option);
                });
                
                try {
                    timezonePicker.value = currentSelectedTz || dayjs.tz.guess();
                } catch (e) {
                    if(timezonePicker.options.length > 0) {
                         timezonePicker.selectedIndex = 0;
                       }
                }
            }
            
           // --- CORE CALCULATION & DRAWING ---
function calculateAndDraw() {
    const userLat = parseFloat(latInput.value);
    const userLon = parseFloat(lonInput.value);
    if (!Number.isFinite(userLat) || !Number.isFinite(userLon)) return;

    // Parse dimensions
    const heightVal = parseFloat(heightInput.value);
    const diameterVal = parseFloat(diameterInput.value);
    const heightInFeet = heightUnitM.classList.contains('active-unit') ? heightVal * METERS_TO_FEET : heightVal;
    const diameterInFeet = diameterUnitM.classList.contains('active-unit') ? diameterVal * METERS_TO_FEET : diameterVal;

    if (!Number.isFinite(heightInFeet) || !Number.isFinite(diameterInFeet) || heightInFeet <= 0 || diameterInFeet <= 0) return;

    // --- Handle solar altitude properly ---
    // Avoid infinite shadows by clamping minimum altitude angle
    const ALTITUDE_FLOOR_DEG = 3; // minimum angle above horizon in deg
    const ALTITUDE_FLOOR_RAD = ALTITUDE_FLOOR_DEG * Math.PI / 180;

    const rawAltRad = Number.isFinite(MIN_ALTITUDE_RAD) ? MIN_ALTITUDE_RAD : 0;
    const altitudeAbsRad = Math.max(Math.abs(rawAltRad), ALTITUDE_FLOOR_RAD);

    // Shadow length in feet, always positive
    const shadowLengthFeet = heightInFeet / Math.tan(altitudeAbsRad);

    // --- Scaling based on umbrella + shadow ---
    const totalPathWidthGuess = diameterInFeet * 2 + shadowLengthFeet;
    if (!Number.isFinite(totalPathWidthGuess) || totalPathWidthGuess <= 0) return;

    const scale = VIEWBOX_SIZE / totalPathWidthGuess;

    // Umbrella radius
    const radiusScaled = (diameterInFeet / 2) * scale;
    umbrellaSVG.setAttribute('r', radiusScaled);

    // --- Shadow path drawing ---
    const cx = VIEWBOX_SIZE / 2;
    const cy = VIEWBOX_SIZE / 2;

    const shadowLengthScaled = shadowLengthFeet * scale;

    // Hemisphere-aware sweep direction
    const sweepFlag = userLat >= 0 ? 1 : 0; // Northern Hemisphere = clockwise, Southern = counterclockwise

    // If you want to later support sun azimuth angles, plug them here:
    const azimuthRad = 0; // TODO: Replace with actual azimuth for dynamic shadows

    // Shadow endpoint based on current azimuth
    const shadowEndX = cx + shadowLengthScaled * Math.cos(azimuthRad);
    const shadowEndY = cy + shadowLengthScaled * Math.sin(azimuthRad);

    // Build the SVG path string
    const shadowPath = `
        M ${cx} ${cy}
        A ${shadowLengthScaled} ${shadowLengthScaled} 0 0 ${sweepFlag} ${shadowEndX} ${shadowEndY}
    `;

    // Apply to the shadow path element
    shadowSVG.setAttribute("d", shadowPath);
}


                // --- Draw Grid ---
                gridOverlay.innerHTML = '';
                const gridSpacingFeet = 2;
                const gridSpacingSVG = gridSpacingFeet * scale;
                for (let x = 100; x < VIEWBOX_SIZE; x += gridSpacingSVG) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x); line.setAttribute('y1', 0); line.setAttribute('x2', x); line.setAttribute('y2', VIEWBOX_SIZE);
                    line.setAttribute('stroke', 'currentColor'); line.setAttribute('stroke-width', '0.25'); line.setAttribute('class', 'opacity-20');
                    gridOverlay.appendChild(line);
                }
                 for (let x = 100 - gridSpacingSVG; x > 0; x -= gridSpacingSVG) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x); line.setAttribute('y1', 0); line.setAttribute('x2', x); line.setAttribute('y2', VIEWBOX_SIZE);
                    line.setAttribute('stroke', 'currentColor'); line.setAttribute('stroke-width', '0.25'); line.setAttribute('class', 'opacity-20');
                    gridOverlay.appendChild(line);
                }
                 for (let y = 100; y < VIEWBOX_SIZE; y += gridSpacingSVG) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', 0); line.setAttribute('y1', y); line.setAttribute('x2', VIEWBOX_SIZE); line.setAttribute('y2', y);
                    line.setAttribute('stroke', 'currentColor'); line.setAttribute('stroke-width', '0.25'); line.setAttribute('class', 'opacity-20');
                    gridOverlay.appendChild(line);
                }
                 for (let y = 100 - gridSpacingSVG; y > 0; y -= gridSpacingSVG) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', 0); line.setAttribute('y1', y); line.setAttribute('x2', VIEWBOX_SIZE); line.setAttribute('y2', y);
                    line.setAttribute('stroke', 'currentColor'); line.setAttribute('stroke-width', '0.25'); line.setAttribute('class', 'opacity-20');
                    gridOverlay.appendChild(line);
                }
                
                const now = getCombinedDate();
                const sunPosition = SunCalc.getPosition(now, userLat, userLon);
                const sunTimes = SunCalc.getTimes(now, userLat, userLon);
                const azimuthCorrection = userLat >= 0 ? Math.PI : 0;

                // --- Draw Hourly Dots ---
                hourlyDotsGroup.innerHTML = ''; // Clear previous dots
                if (sunTimes.sunrise instanceof Date && !isNaN(sunTimes.sunrise)) {
                    let hourMarker = new Date(sunTimes.sunrise);
                    if (hourMarker.getMinutes() !== 0 || hourMarker.getSeconds() !== 0 || hourMarker.getMilliseconds() !== 0) {
                        hourMarker.setHours(hourMarker.getHours() + 1);
                        hourMarker.setMinutes(0, 0, 0);
                    }
                    while (hourMarker < sunTimes.sunset) {
                        const pos = SunCalc.getPosition(hourMarker, userLat, userLon);
                        if (pos.altitude > 0) {
                            const universalAzimuth = pos.azimuth + azimuthCorrection;
                            const offset = (heightInFeet / Math.tan(pos.altitude)) * scale;
                            const shadowX = 100 - offset * Math.sin(universalAzimuth);
                            const shadowY = 100 + offset * Math.cos(universalAzimuth);

                            const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                            dot.setAttribute('cx', shadowX.toFixed(2));
                            dot.setAttribute('cy', shadowY.toFixed(2));
                            dot.setAttribute('r', '1.5');
                            dot.setAttribute('fill', 'white');
                            dot.setAttribute('fill-opacity', '0.7');
                            hourlyDotsGroup.appendChild(dot);
                        }
                        hourMarker.setHours(hourMarker.getHours() + 1);
                    }
                }
                
                // --- Accurately draw the entire day's shade path ---
                const shadowSteps = [];
                dailySunPath = []; // Clear for recalculation
                const stepMinutes = 1;
                
                if (sunTimes.sunrise instanceof Date && !isNaN(sunTimes.sunrise)) {
                    let currentTime = new Date(sunTimes.sunrise);
                    while (currentTime <= sunTimes.sunset) {
                        const pos = SunCalc.getPosition(currentTime, userLat, userLon);
                        if (pos.altitude > MIN_ALTITUDE_RAD) {
                            const universalAzimuth = pos.azimuth + azimuthCorrection;
                            const offset = (heightInFeet / Math.tan(pos.altitude)) * scale;
                            const shadowX = 100 - offset * Math.sin(universalAzimuth);
                            const shadowY = 100 + offset * Math.cos(universalAzimuth);
                            
                            const stepData = {
                                center: { x: shadowX, y: shadowY },
                                rx: radiusScaled / Math.sin(pos.altitude),
                                ry: radiusScaled,
                                rotationRad: pos.azimuth + Math.PI / 2
                            };
                            shadowSteps.push(stepData);
                            const currentMinutes = currentTime.getHours() * 60 + currentTime.getMinutes();
                            dailySunPath.push({ minutes: currentMinutes, center: stepData.center });
                        }
                        currentTime.setMinutes(currentTime.getMinutes() + stepMinutes);
                    }
                }
                
                if (shadowSteps.length > 2) {
                    const leftPoints = [];
                    const rightPoints = [];

                    for (let i = 0; i < shadowSteps.length; i++) {
                        const step = shadowSteps[i];
                        
                        let tangentDx, tangentDy;
                        if (i === 0) {
                            tangentDx = shadowSteps[i + 1].center.x - step.center.x;
                            tangentDy = shadowSteps[i + 1].center.y - step.center.y;
                        } else if (i === shadowSteps.length - 1) {
                            tangentDx = step.center.x - shadowSteps[i - 1].center.x;
                            tangentDy = step.center.y - shadowSteps[i - 1].center.y;
                        } else {
                            tangentDx = shadowSteps[i + 1].center.x - shadowSteps[i - 1].center.x;
                            tangentDy = shadowSteps[i + 1].center.y - shadowSteps[i - 1].center.y;
                        }

                        const nx = -tangentDy;
                        const ny = tangentDx;

                        let maxDot = -Infinity;
                        let minDot = Infinity;
                        let pLeft, pRight;

                        for (let j = 0; j < 360; j += 15) {
                            const angleRad = j * (Math.PI / 180);
                            const x_rot = step.rx * Math.cos(angleRad);
                            const y_rot = step.ry * Math.sin(angleRad);
                            
                            const x = step.center.x + x_rot * Math.cos(step.rotationRad) - y_rot * Math.sin(step.rotationRad);
                            const y = step.center.y + x_rot * Math.sin(step.rotationRad) + y_rot * Math.cos(step.rotationRad);
                            
                            const dot = (x - step.center.x) * nx + (y - step.center.y) * ny;
                            
                            if (dot > maxDot) { maxDot = dot; pRight = {x, y}; }
                            if (dot < minDot) { minDot = dot; pLeft = {x, y}; }
                        }
                        if (pLeft) leftPoints.push(pLeft);
                        if (pRight) rightPoints.push(pRight);
                    }

                    if (leftPoints.length > 1 && rightPoints.length > 1) {
                        const rightPointsReversed = rightPoints.reverse();
                        const pathD = "M" + leftPoints.map(p => `${p.x.toFixed(2)},${p.y.toFixed(2)}`).join(" L ")
                                      + " L " + rightPointsReversed.map(p => `${p.x.toFixed(2)},${p.y.toFixed(2)}`).join(" L ")
                                      + " Z";
                        shadowPath.setAttribute('d', pathD);
                    } else {
                         shadowPath.setAttribute('d', '');
                    }

                } else {
                    shadowPath.setAttribute('d', '');
                }


                // --- Draw Current Shade & Position ---
                if (sunPosition.altitude <= 0) {
                    nightMessage.classList.remove('hidden');
                    shadowSVG.classList.add('hidden');
                    centerPosText.textContent = '';
                    shadeDimsText.textContent = '';
                    return;
                }
                
                nightMessage.classList.add('hidden');
                shadowSVG.classList.remove('hidden');
            
                const universalSunAzimuth = sunPosition.azimuth + azimuthCorrection;
                const shadowOffset = (heightInFeet / Math.tan(sunPosition.altitude)) * scale;
                const shadowX = 100 - shadowOffset * Math.sin(universalSunAzimuth);
                const shadowY = 100 + shadowOffset * Math.cos(universalSunAzimuth);
                
                const elongatedRadius = radiusScaled / Math.sin(sunPosition.altitude);
                const rotationRad = sunPosition.azimuth + Math.PI / 2;
                const rotationDegrees = rotationRad * (180 / Math.PI);

                shadowSVG.setAttribute('cx', shadowX);
                shadowSVG.setAttribute('cy', shadowY);
                shadowSVG.setAttribute('rx', elongatedRadius);
                shadowSVG.setAttribute('ry', radiusScaled);
                shadowSVG.setAttribute('transform', `rotate(${rotationDegrees} ${shadowX} ${shadowY})`);
                
                // --- Display Text Info ---
                const shortAxisFeet = diameterInFeet;
                const longAxisFeet = diameterInFeet / Math.sin(sunPosition.altitude);
                const shortAxisMeters = shortAxisFeet * FEET_TO_METERS;
                const longAxisMeters = longAxisFeet * FEET_TO_METERS;
                
                shadeDimsText.textContent = `Shade Coverage: ${longAxisFeet.toFixed(1)}'x${shortAxisFeet.toFixed(1)}' (${longAxisMeters.toFixed(1)}x${shortAxisMeters.toFixed(1)}m)`;

                const offsetEastWest_feet = (shadowX - 100) / scale;
                const offsetNorthSouth_feet = -(shadowY - 100) / scale;
                
                const offsetEastWest_meters = offsetEastWest_feet * FEET_TO_METERS;
                const offsetNorthSouth_meters = offsetNorthSouth_feet * FEET_TO_METERS;
                
                const ewDistFt = Math.abs(offsetEastWest_feet);
                const ewDistM = Math.abs(offsetEastWest_meters);
                const ewTextContent = `${ewDistFt.toFixed(1)}' (${ewDistM.toFixed(1)}m) ${offsetEastWest_feet >= 0 ? 'E' : 'W'}`;
                
                const nsDistFt = Math.abs(offsetNorthSouth_feet);
                const nsDistM = Math.abs(offsetNorthSouth_meters);
                const nsTextContent = `${nsDistFt.toFixed(1)}' (${nsDistM.toFixed(1)}m) ${offsetNorthSouth_feet >= 0 ? 'N' : 'S'}`;
                
                centerPosText.textContent = `Center: ${nsTextContent} & ${ewTextContent}`;
            }

            // --- Dragging Logic ---
            function getSVGCoords(e) {
                const pt = svg.createSVGPoint();
                if (e.touches) {
                    pt.x = e.touches[0].clientX;
                    pt.y = e.touches[0].clientY;
                } else {
                    pt.x = e.clientX;
                    pt.y = e.clientY;
                }
                return pt.matrixTransform(svg.getScreenCTM().inverse());
            }

            function findClosestTime(pos) {
                if (dailySunPath.length === 0) return 720; // Default to noon

                let closest = null;
                let minDistance = Infinity;

                dailySunPath.forEach(point => {
                    const dx = point.center.x - pos.x;
                    const dy = point.center.y - pos.y;
                    const distance = dx * dx + dy * dy;
                    if (distance < minDistance) {
                        minDistance = distance;
                        closest = point;
                    }
                });
                return closest ? closest.minutes : 720;
            }

            function startDrag(e) {
                e.preventDefault();
                isDragging = true;
            }

            function drag(e) {
                if (!isDragging) return;
                e.preventDefault();
                const coords = getSVGCoords(e);
                const newTimeInMinutes = findClosestTime(coords);
                
                const hours = Math.floor(newTimeInMinutes / 60);
                const minutes = newTimeInMinutes % 60;
                timeInputBox.value = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
                
                calculateAndDraw();
            }
            
            function endDrag() {
                isDragging = false;
            }

            // --- GEOLOCATION ---
            function getLocation() {
                loader.style.display = 'flex';
                errorMessage.classList.add('hidden');
                latInput.disabled = true;
                lonInput.disabled = true;
                 if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            latInput.value = position.coords.latitude.toFixed(4);
                            lonInput.value = position.coords.longitude.toFixed(4);
                            loader.style.display = 'none';
                            latInput.disabled = false;
                            lonInput.disabled = false;
                            calculateAndDraw();
                        },
                        () => handleLocationError("Could not get location. Using default.")
                    );
                } else {
                    handleLocationError("Geolocation not supported. Using default.");
                }
            }

            function handleLocationError(message) {
                 latInput.value = (37.5629).toFixed(4);
                 lonInput.value = (-122.3255).toFixed(4);
                 errorMessage.textContent = message;
                 errorMessage.classList.remove('hidden');
                 loader.style.display = 'none';
                 latInput.disabled = false;
                 lonInput.disabled = false;
                 calculateAndDraw();
            }

            // --- EVENT LISTENERS ---
            dateInput.addEventListener('input', () => {
                populateTimezonePicker();
                calculateAndDraw();
            });

            [heightInput, diameterInput, latInput, lonInput, timezonePicker, timeInputBox].forEach(el => {
                if (el) { // Check if element exists before adding listener
                    el.addEventListener('input', calculateAndDraw);
                }
            });
            
            shadowSVG.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', endDrag);
            shadowSVG.addEventListener('touchstart', startDrag, { passive: false });
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('touchend', endDrag);

            heightUnitFt.addEventListener('click', () => setUnit('height', 'ft'));
            heightUnitM.addEventListener('click', () => setUnit('height', 'm'));
            diameterUnitFt.addEventListener('click', () => setUnit('diameter', 'ft'));
            diameterUnitM.addEventListener('click', () => setUnit('diameter', 'm'));

            dateResetBtn.addEventListener('click', () => {
                dateInput.value = dayjs().format('YYYY-MM-DD');
                dateInput.dispatchEvent(new Event('input')); // Trigger timezone update and redraw
            });

            timeResetBtn.addEventListener('click', () => {
                const now = dayjs();
                timeInputBox.value = now.format('HH:mm');
                timezonePicker.value = dayjs.tz.guess();
                calculateAndDraw();
            });
            
            timezoneResetBtn.addEventListener('click', () => {
                timezonePicker.value = dayjs.tz.guess();
                calculateAndDraw();
            });

            getLocationBtn.addEventListener('click', getLocation);

            // --- INITIALIZATION ---
            function initialize() {
                const now = dayjs();
                timeInputBox.value = now.format('HH:mm');
                dateInput.value = now.format('YYYY-MM-DD');

                populateTimezonePicker();
                
                getLocation();
            }

            initialize();
        });
    </script>
</body>
</html>

